<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸŒŠ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            overflow: hidden;
            background: #000;
            height: 100%;
            width: 100%;
            position: fixed;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Simulation resolution
        const simRes = 512;
        let width, height;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);
        }
        resize();
        window.addEventListener('resize', resize);

        // Vertex shader - simple fullscreen quad
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment shader for adding drops only
        const dropFragmentSource = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_texture;
            uniform vec2 u_dropPos;
            uniform float u_dropRadius;
            uniform float u_dropStrength;

            void main() {
                vec4 current = texture2D(u_texture, v_uv);
                float height = current.r;
                float velocity = current.g;

                // Add drop
                float dist = distance(v_uv, u_dropPos);
                if (dist < u_dropRadius) {
                    float strength = (1.0 - dist / u_dropRadius) * u_dropStrength;
                    height += strength;
                }

                gl_FragColor = vec4(height, velocity, 0.0, 1.0);
            }
        `;

        // Fragment shader for water simulation (wave equation only)
        const simFragmentSource = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_texture;
            uniform vec2 u_resolution;

            void main() {
                vec2 texel = 1.0 / u_resolution;

                // Sample neighboring heights
                float center = texture2D(u_texture, v_uv).r;
                float left = texture2D(u_texture, v_uv - vec2(texel.x, 0.0)).r;
                float right = texture2D(u_texture, v_uv + vec2(texel.x, 0.0)).r;
                float top = texture2D(u_texture, v_uv - vec2(0.0, texel.y)).r;
                float bottom = texture2D(u_texture, v_uv + vec2(0.0, texel.y)).r;

                // Get velocity from green channel
                float velocity = texture2D(u_texture, v_uv).g;

                // Wave equation
                float average = (left + right + top + bottom) * 0.25;
                velocity += (average - center) * 2.0;
                velocity *= 0.995; // Damping - higher = longer lasting

                float newHeight = center + velocity;

                gl_FragColor = vec4(newHeight, velocity, 0.0, 1.0);
            }
        `;

        // Fragment shader for rendering water
        const renderFragmentSource = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_texture;
            uniform vec2 u_resolution;
            uniform float u_time;

            void main() {
                vec2 texel = 1.0 / u_resolution;

                // Calculate normals from height differences
                float left = texture2D(u_texture, v_uv - vec2(texel.x, 0.0)).r;
                float right = texture2D(u_texture, v_uv + vec2(texel.x, 0.0)).r;
                float top = texture2D(u_texture, v_uv - vec2(0.0, texel.y)).r;
                float bottom = texture2D(u_texture, v_uv + vec2(0.0, texel.y)).r;

                vec2 normal = vec2(left - right, top - bottom) * 10.0;

                // Refraction/distortion
                vec2 refractedUV = v_uv + normal * 0.015;

                // Deep ocean water gradient
                vec3 topColor = vec3(0.0, 0.35, 0.45);
                vec3 bottomColor = vec3(0.0, 0.12, 0.18);
                vec3 baseColor = mix(bottomColor, topColor, v_uv.y);

                // Lighting based on normals
                vec3 lightDir = normalize(vec3(0.3, 0.4, 1.0));
                vec3 surfaceNormal = normalize(vec3(normal.x, normal.y, 1.0));
                float diffuse = max(dot(surfaceNormal, lightDir), 0.0);

                // Specular highlight
                vec3 viewDir = vec3(0.0, 0.0, 1.0);
                vec3 reflectDir = reflect(-lightDir, surfaceNormal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);

                // Combine - gradient base with ripple lighting
                vec3 color = baseColor;
                color += diffuse * 0.15;
                color += spec * vec3(0.7, 0.9, 0.95) * 0.5;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const dropProgram = createProgram(vertexShaderSource, dropFragmentSource);
        const simProgram = createProgram(vertexShaderSource, simFragmentSource);
        const renderProgram = createProgram(vertexShaderSource, renderFragmentSource);

        // Get uniform and attribute locations
        const dropUniforms = {
            texture: gl.getUniformLocation(dropProgram, 'u_texture'),
            dropPos: gl.getUniformLocation(dropProgram, 'u_dropPos'),
            dropRadius: gl.getUniformLocation(dropProgram, 'u_dropRadius'),
            dropStrength: gl.getUniformLocation(dropProgram, 'u_dropStrength')
        };

        const simUniforms = {
            texture: gl.getUniformLocation(simProgram, 'u_texture'),
            resolution: gl.getUniformLocation(simProgram, 'u_resolution')
        };

        const renderUniforms = {
            texture: gl.getUniformLocation(renderProgram, 'u_texture'),
            resolution: gl.getUniformLocation(renderProgram, 'u_resolution'),
            time: gl.getUniformLocation(renderProgram, 'u_time')
        };

        // Create fullscreen quad
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);

        // Create framebuffers for ping-pong rendering
        function createFramebuffer() {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, simRes, simRes, 0, gl.RGBA, gl.FLOAT, null);

            // Fallback for devices without float texture support
            if (gl.getError() !== gl.NO_ERROR) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, simRes, simRes, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            const fb = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            return { framebuffer: fb, texture: texture };
        }

        // Enable float textures extension
        gl.getExtension('OES_texture_float');
        gl.getExtension('OES_texture_float_linear');

        let fb1 = createFramebuffer();
        let fb2 = createFramebuffer();

        // Mouse interaction
        let mouseX = -1, mouseY = -1;
        let prevMouseX = -1, prevMouseY = -1;
        let isMouseDown = false;
        let dropQueue = [];

        function addDrop(x, y, radius, strength) {
            dropQueue.push({ x, y, radius, strength });
        }

        function addDropsAlongPath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Scale size based on velocity (distance is proxy for speed)
            const velocityMult = Math.min(dist * 15, 3); // Cap at 3x
            const radius = 0.02 + 0.03 * velocityMult;
            const strength = 0.04 + 0.08 * velocityMult;

            const step = 0.01;
            const steps = Math.max(1, Math.floor(dist / step));

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + dx * t;
                const y = y1 + dy * t;
                addDrop(x, y, radius, strength / steps);
            }
        }

        // Mouse events for desktop
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) / rect.width;
            mouseY = 1.0 - (e.clientY - rect.top) / rect.height;

            if (prevMouseX >= 0 && prevMouseY >= 0) {
                addDropsAlongPath(prevMouseX, prevMouseY, mouseX, mouseY);
            } else {
                addDrop(mouseX, mouseY, 0.02, 0.04);
            }

            prevMouseX = mouseX;
            prevMouseY = mouseY;
        });

        canvas.addEventListener('mouseleave', () => {
            prevMouseX = -1;
            prevMouseY = -1;
        });

        // Touch events for mobile (iOS Safari compatible) - must use window, not document
        window.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            prevMouseX = (touch.clientX - rect.left) / rect.width;
            prevMouseY = 1.0 - (touch.clientY - rect.top) / rect.height;
            addDrop(prevMouseX, prevMouseY, 0.05, 0.15);
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = (touch.clientX - rect.left) / rect.width;
            mouseY = 1.0 - (touch.clientY - rect.top) / rect.height;

            if (prevMouseX >= 0 && prevMouseY >= 0) {
                addDropsAlongPath(prevMouseX, prevMouseY, mouseX, mouseY);
            } else {
                addDrop(mouseX, mouseY, 0.05, 0.15);
            }

            prevMouseX = mouseX;
            prevMouseY = mouseY;
        }, { passive: false });

        window.addEventListener('touchend', () => {
            prevMouseX = -1;
            prevMouseY = -1;
        });


        function setupQuadAttribute(program) {
            const positionLoc = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        }

        let lastTime = 0;
        function animate(time) {
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            // Step 1: Apply all drops (separate from simulation)
            const drops = dropQueue.splice(0, dropQueue.length);
            if (drops.length > 0) {
                gl.useProgram(dropProgram);
                setupQuadAttribute(dropProgram);

                for (const drop of drops) {
                    gl.uniform2f(dropUniforms.dropPos, drop.x, drop.y);
                    gl.uniform1f(dropUniforms.dropRadius, drop.radius);
                    gl.uniform1f(dropUniforms.dropStrength, drop.strength);

                    gl.bindFramebuffer(gl.FRAMEBUFFER, fb2.framebuffer);
                    gl.viewport(0, 0, simRes, simRes);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, fb1.texture);
                    gl.uniform1i(dropUniforms.texture, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);

                    [fb1, fb2] = [fb2, fb1];
                }
            }

            // Step 2: Run wave simulation exactly once
            gl.useProgram(simProgram);
            setupQuadAttribute(simProgram);
            gl.uniform2f(simUniforms.resolution, simRes, simRes);

            gl.bindFramebuffer(gl.FRAMEBUFFER, fb2.framebuffer);
            gl.viewport(0, 0, simRes, simRes);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fb1.texture);
            gl.uniform1i(simUniforms.texture, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            [fb1, fb2] = [fb2, fb1];

            // Render to screen
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, width, height);
            gl.useProgram(renderProgram);
            setupQuadAttribute(renderProgram);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fb1.texture);
            gl.uniform1i(renderUniforms.texture, 0);
            gl.uniform2f(renderUniforms.resolution, simRes, simRes);
            gl.uniform1f(renderUniforms.time, time * 0.001);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
